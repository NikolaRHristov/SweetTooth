class d{reactives=new Map;plugins=new Map;middleware=[];history=new Map;batchQueue=new Map;subscriptions=new Map;options;constructor(e={}){this.options={enableHistory:!1,historySize:10,asyncTimeout:5e3,batchUpdates:!1,devTools:!1,...e.options},this.initializePlugins(e.plugins||[]),this.middleware=e.middleware||[],this.options.devTools&&this.setupDevTools()}initializePlugins(e){e.forEach(t=>{this.plugins.set(t.name,t),t.initialize?.(this.createSystemContext())})}createSystemContext(){return{reactives:this.reactives,history:this.history,options:this.options,registerReactive:this.registerReactive.bind(this),removeReactive:this.removeReactive.bind(this),getReactive:this.getReactive.bind(this),batch:this.batch.bind(this),subscribe:this.subscribe.bind(this),unsubscribe:this.unsubscribe.bind(this)}}async create(e){const t=await this.runPluginHook("beforeCreate",e),i=await this.createReactive(t);return await this.runPluginHook("afterCreate",i),i}async createReactive(e){const t={id:e.id||crypto.randomUUID(),value:()=>e.initialValue,meta:{type:e.type,created:new Date,updateCount:0,status:"idle",custom:{}},dependencies:new Set(e.dependencies||[]),dependents:new Set};return e.type!=="readonly"&&(t.set=async i=>{try{const a=await this.runMiddleware("before",i,{reactive:t});await this.updateReactiveValue(t,a),await this.runMiddleware("after",t.value(),{reactive:t})}catch(a){await this.handleError(a,{reactive:t,phase:"update"})}}),this.registerReactive(t),t}async updateReactiveValue(e,t){if(this.options.batchUpdates&&this.batchQueue.size>0){this.batchQueue.set(e.id,t);return}const i=e.value(),a=await this.runPluginHook("beforeUpdate",t,i),s={current:a};e.value=()=>s.current,e.meta.lastUpdated=new Date,e.meta.updateCount++,this.options.enableHistory&&this.updateHistory(e.id,i),await this.notifyDependents(e),await this.runPluginHook("afterUpdate",a)}batch(e){return new Promise((t,i)=>{Promise.all(e.map(a=>a())).then(()=>{const a=Array.from(this.batchQueue.entries());return this.batchQueue.clear(),Promise.all(a.map(([s,n])=>this.getReactive(s)?.set?.(n)))}).then(t).catch(i)})}async notifyDependents(e){const t=new Set,i=Array.from(e.dependents);for(;i.length>0;){const a=i.shift();if(t.has(a))continue;t.add(a);const s=this.getReactive(a);s?.set&&await s.set(s.value()),i.push(...Array.from(s?.dependents||[]))}}async runPluginHook(e,t,...i){let a=t;for(const s of this.plugins.values()){const n=s[e];n&&(a=await n.call(s,a,...i))}return a}async runMiddleware(e,t,i){let a=t;const s=Date.now();for(const n of this.middleware){const c=e==="before"?n.before:n.after;c&&(a=await c(a,{...i,phase:e,timestamp:s}))}return a}async handleError(e,t){t.reactive.meta.status="error",t.reactive.meta.error=e;for(const i of this.plugins.values())await i.handleError?.(e,{phase:t.phase,config:{type:t.reactive.meta.type}});for(const i of this.middleware)await i.error?.(e,{reactive:t.reactive,phase:"error",timestamp:Date.now(),meta:{}});throw e}updateHistory(e,t){this.history.has(e)||this.history.set(e,[]);const i=this.history.get(e);i.push(t),i.length>this.options.historySize&&i.shift()}setupDevTools(){const e={getState:()=>({reactives:Array.from(this.reactives.entries()),history:Array.from(this.history.entries()),plugins:Array.from(this.plugins.keys()),middleware:this.middleware.map(t=>t.name)}),subscribe:t=>{const i=()=>t(e.getState());return this.subscriptions.set("devtools",new Set([i])),()=>this.subscriptions.get("devtools")?.delete(i)}};window.__COMPONENT_DEVTOOLS__=e}getReactive(e){return this.reactives.get(e)}registerReactive(e){this.reactives.set(e.id,e)}removeReactive(e){const t=this.reactives.get(e);t&&(this.runPluginHook("beforeDestroy",t),this.reactives.delete(e),this.history.delete(e),this.subscriptions.delete(e))}subscribe(e,t){return this.subscriptions.has(e)||this.subscriptions.set(e,new Set),this.subscriptions.get(e).add(t),()=>this.subscriptions.get(e)?.delete(t)}unsubscribe(e){this.subscriptions.delete(e)}}const u={name:"logger",initialize:r=>{console.log("Logger plugin initialized")},beforeCreate:r=>(console.log("Creating reactive:",r),r),afterCreate:r=>{console.log("Reactive created:",r)},handleError:(r,e)=>{console.error("Error in reactive:",r,e)}},l={name:"persistence",initialize:r=>{const e=localStorage.getItem("reactives");if(e){const t=JSON.parse(e);Object.entries(t).forEach(([i,a])=>{r.registerReactive({id:i,value:()=>a,meta:{type:"persisted",created:new Date,updateCount:0,status:"idle",custom:{}},dependencies:new Set,dependents:new Set})})}},afterUpdate:r=>{const e=Array.from(window.componentSystem.reactives.entries()).reduce((t,[i,a])=>({...t,[i]:a.value()}),{});localStorage.setItem("reactives",JSON.stringify(e))}},o=new d({plugins:[u,l],middleware:[{name:"validation",before:(r,e)=>{if(r===null)throw new Error("Value cannot be null");return r}}],options:{enableHistory:!0,batchUpdates:!0,devTools:!0}});async function p(){const r=await o.create({id:"count",type:"state",initialValue:0}),e=await o.create({id:"doubled",type:"computed",initialValue:0,dependencies:["count"]});await o.batch([async()=>await r.set(1),async()=>await r.set(2),async()=>await r.set(3)])}export{d as ComponentSystem,u as LoggerPlugin,l as PersistencePlugin};
