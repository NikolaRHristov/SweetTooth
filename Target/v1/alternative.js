import{createMemo as x,createResource as b,createRoot as w,createSignal as K,onCleanup as v}from"solid-js";function E(l){return w(k=>{const c={},i={},u={},y=new Map,f=new Map;function p(e,t){return t?.length?t.reduce((r,s)=>s(r),r=>r)(e):e}async function T(e,t){if(!t)return!0;try{return await t(e)}catch{return!1}}function g(e,t){y.get(e)?.forEach(n=>n(t))}function d(e,t){const n=e;switch(e.type){case"signal":{const[r,s]=K(n.initialValue);c[t]=[r,s],i[t]=()=>{const a=r();return p(n.getter?n.getter(a):a,n.middleware)},u[t]=async a=>{try{const o=n.transform?n.transform(a):a;await T(o,n.validate)?(s(C=>n.setter?n.setter(C,o):o),n.onSuccess?.(o),g(t,o)):n.onError?.(new Error("Validation failed"))}catch(o){n.onError?.(o)}};break}case"resource":{const[r]=b(()=>e.source&&m([e.source])[0],async(...s)=>{try{const a=JSON.stringify(s);if(e.cacheStrategy&&f.has(a))return f.get(a);const o=await e.fetcher(...s);return e.cacheStrategy&&f.set(a,o),n.onSuccess?.(o),o}catch(a){throw n.onError?.(a),a}});if(e.refetchInterval){const s=setInterval(()=>r.refetch(),e.refetchInterval);v(()=>clearInterval(s))}c[t]=r,i[t]=()=>r();break}case"computed":{c[t]=x(()=>{try{const r=e.computed({getters:i,setters:u,reactives:c});return n.onSuccess?.(r),r}catch(r){throw n.onError?.(r),r}}),i[t]=()=>c[t]();break}}}function m(e){return e?e.map(t=>typeof t=="string"?i[t]():t()):[]}for(const[e,t]of Object.entries(l))d(t,e);const h={reactives:c,getters:i,setters:u,addReactive:(e,t)=>d(t,e),removeReactive:e=>{delete c[e],delete i[e],delete u[e],y.delete(e)},reset:()=>{Object.keys(l).forEach(e=>{const t=l[e];t.type==="signal"&&u[e]?.(t.initialValue)})},subscribe:(e,t)=>(y.has(e)||y.set(e,new Set),y.get(e).add(t),()=>y.get(e).delete(t))};return v(()=>{y.clear(),f.clear(),Object.values(l).forEach(e=>e.dispose?.())}),h})}export{E as createComponentFactory};
